<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaflet Route Planner - Multiple Stops with Labels</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', Arial, sans-serif; /* Using Inter font */
            overflow: hidden; /* Prevent body scroll */
        }

        #map {
            width: 100%;
            height: 100vh;
            border-radius: 10px; /* Rounded corners for map */
        }

        .route-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 200px;
            font-size: 12px;
        }

        /* Custom marker styles */
        .custom-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-weight: bold;
            font-size: 12px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .start-marker {
            background-color: #4CAF50; /* Green */
            width: 20px;
            height: 20px;
        }

        .stop-marker {
            background-color: #FF9800; /* Orange */
            width: 20px;
            height: 20px;
        }

        .end-marker {
            background-color: #F44336; /* Red */
            width: 20px;
            height: 20px;
        }

        /* Routing Container Styling */
        .leaflet-routing-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
            font-family: 'Inter', Tahoma, Geneva, Verdana, sans-serif; /* Using Inter font */
            max-width: 300px;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            overflow: hidden; /* Ensure rounded corners clip content */
        }

        .leaflet-routing-container h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: #1976D2;
            font-weight: 600;
            padding: 12px 15px 0 15px;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 8px;
        }

        .leaflet-routing-container h3 {
            font-size: 14px;
            margin: 8px 0;
            color: #4285F4;
            font-weight: 500;
            background: #f8f9fa;
            padding: 8px 15px;
            margin: 0;
            border-radius: 6px;
            margin: 8px 12px;
        }

        .leaflet-routing-container .leaflet-routing-collapse-btn {
            background: #4285F4;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .leaflet-routing-container .leaflet-routing-collapse-btn:hover {
            background: #1976D2;
        }

        .leaflet-routing-container .leaflet-routing-instruction {
            padding: 8px 15px;
            border-bottom: 1px solid #f5f5f5;
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }

        .leaflet-routing-container .leaflet-routing-instruction:hover {
            background: #f8f9fa;
        }

        .leaflet-routing-container .leaflet-routing-instruction:last-child {
            border-bottom: none;
        }

        .leaflet-routing-container .leaflet-routing-instruction-distance {
            color: #666;
            font-size: 11px;
            font-weight: 500;
        }

        .leaflet-routing-container .leaflet-routing-alt {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            margin: 8px 12px;
            padding: 8px;
        }

        .leaflet-routing-container .leaflet-routing-instructions {
            max-height: 200px;
            overflow-y: auto;
            border-radius: 0 0 10px 10px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar {
            width: 6px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar-thumb {
            background: #4285F4;
            border-radius: 3px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar-thumb:hover {
            background: #1976D2;
        }

        .leaflet-routing-container.collapsed {
            height: 60px;
            overflow: hidden;
        }

        .leaflet-routing-container.collapsed .leaflet-routing-instructions {
            display: none;
        }

        /* Loading indicator styles */
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 2000;
            display: none; /* Hidden by default */
            font-size: 16px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        #loading-indicator .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-right: 10px;
            display: inline-block;
            vertical-align: middle;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div id="map"></div>
<div id="loading-indicator">
    <span class="spinner"></span>
    Calculating optimal route...
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

<script>
    // Initialize the map with default location
    let map = L.map('map', { zoomControl: false }).setView([28.6139, 77.2090], 10);

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    // Store markers and routes
    let markers = [];
    let currentRoute = null;
    let currentWaypoints = []; // Store the last set of waypoints used for routing
    let currentWaypointNames = []; // Store the last set of waypoint names

    // Function to create custom marker with label
    function createCustomMarker(type, label = '') {
        let className = 'custom-marker ';
        let content = label;

        switch(type) {
            case 'start':
                className += 'start-marker';
                content = ''; // Start point has no label
                break;
            case 'stop':
                className += 'stop-marker';
                break;
            case 'end':
                className += 'end-marker';
                content = 'E'; // End point has 'E' label
                break;
        }

        return L.divIcon({
            html: `<div class="${className}">${content}</div>`,
            iconSize: [20, 20],
            className: 'custom-div-icon'
        });
    }

    // Function to calculate stop index (similar to Android adapter)
    function getStopIndex(position, waypoints) {
        let stopCount = 0;
        for (let i = 0; i < position; i++) {
            if (i !== 0 && i !== waypoints.length - 1) {
                stopCount++;
            }
        }
        return stopCount;
    }

    // Function to get alphabetical label for stops
    function getStopLabel(stopIndex) {
        return String.fromCharCode(65 + stopIndex); // A, B, C, etc.
    }

    // Function to update location
    function updateLocation(lat, lng) {
        map.setView([lat, lng], 13);
    }

    // Function to add marker
    function addMarker(lat, lng, popup) {
        let marker = L.marker([lat, lng]).addTo(map);
        if (popup) {
            marker.bindPopup(popup);
        }

        marker.on('click', function() {
            if (typeof Android !== 'undefined') {
                Android.onMarkerClick(lat, lng, popup || 'Marker');
            }
        });

        markers.push(marker);
        return marker;
    }

    // Function to clear all markers
    function clearMarkers() {
        markers.forEach(marker => {
            map.removeLayer(marker);
        });
        markers = [];
    }

    // Function to clear all routes
    function clearRoutes() {
        if (currentRoute) {
            map.removeControl(currentRoute);
            currentRoute = null;
        }
    }

    /**
     * Calculates route details (distance and duration) for a given set of waypoints without rendering on the map.
     * @param {Array<L.LatLng>} waypoints - An array of Leaflet LatLng objects.
     * @returns {Promise<{distance: number, duration: number}|null>} - A promise resolving to an object with total distance (meters) and duration (seconds), or null if an error occurs.
     */
    async function calculateRouteDetails(waypoints) {
        if (waypoints.length < 2) {
            console.warn("Not enough waypoints to calculate route details.");
            return null;
        }

        const coordinates = waypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
        const serviceUrl = `https://router.project-osrm.org/route/v1/driving/${coordinates}?overview=false&alternatives=false&steps=false`;

        try {
            const response = await fetch(serviceUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();

            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                return {
                    distance: route.distance, // meters
                    duration: route.duration   // seconds
                };
            } else {
                console.warn("No routes found for the given waypoints.");
                return null;
            }
        } catch (error) {
            console.error("Error calculating route details:", error);
            return null;
        }
    }

    /**
     * Generates all permutations of an array.
     * @param {Array<any>} arr - The input array.
     * @returns {Array<Array<any>>} - An array containing all permutations.
     */
    function getPermutations(arr) {
        const result = [];

        function permute(current, remaining) {
            if (remaining.length === 0) {
                result.push(current);
                return;
            }

            for (let i = 0; i < remaining.length; i++) {
                const next = current.concat(remaining[i]);
                const newRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1));
                permute(next, newRemaining);
            }
        }

        permute([], arr);
        return result;
    }

    /**
     * Shows the loading indicator.
     */
    function showLoading() {
        document.getElementById('loading-indicator').style.display = 'flex';
    }

    /**
     * Hides the loading indicator.
     */
    function hideLoading() {
        document.getElementById('loading-indicator').style.display = 'none';
    }

    /**
     * Performs smart routing by trying all permutations of stop points to find the optimal route
     * with the minimum time, then updates the map with that route.
     * @param {number} startLat - Latitude of the start point.
     * @param {number} startLng - Longitude of the start point.
     * @param {Array<{lat: number, lng: number, name?: string}>} stopsArray - Array of stop point objects.
     * @param {number} endLat - Latitude of the end point.
     * @param {number} endLng - Longitude of the end point.
     * @param {string} startName - Name of the start point.
     * @param {Array<string>} stopNamesArray - Array of names for stop points.
     * @param {string} endName - Name of the end point.
     */
    async function performSmartRouting(startLat, startLng, stopsArray, endLat, endLng, startName, stopNamesArray, endName) {
    showLoading();
    showToast('Calculating optimal route...');

    if (stopsArray.length === 0) {
        // If no stops, just calculate the direct route
        createRoute(startLat, startLng, endLat, endLng, startName, endName);
        hideLoading();
        // Even for no stops, you might want to call Android to update UI accordingly
        if (typeof Android !== 'undefined' && Android.onSmartRouteCalculated) {
             Android.onSmartRouteCalculated(
                 (minDistance / 1000).toFixed(2), (minDuration / 60).toFixed(0), // Assuming these are defined for direct route too
                 (minDistance / 1000).toFixed(2), (minDuration / 60).toFixed(0), // Max can be same as min for direct
                 2, // Start and End points
                 JSON.stringify([{ lat: startLat, lng: startLng, name: startName, isStartPoint: true, isEndPoint: false }, { lat: endLat, lng: endLng, name: endName, isStartPoint: false, isEndPoint: true }])
             );
        }
        return;
    }

    const startPoint = L.latLng(startLat, startLng);
    const endPoint = L.latLng(endLat, endLng);

    // Convert stop objects to L.LatLng for permutation
    const stopLatLngs = stopsArray.map(s => L.latLng(s.lat, s.lng));
    const stopOriginalNames = stopsArray.map(s => s.name || '');

    const permutations = getPermutations(stopLatLngs);
    let minDuration = Infinity;
    let optimalRouteWaypoints = [];
    let optimalRouteNames = [];
    let maxDuration = 0;
    let minDistance = Infinity;
    let maxDistance = 0;

    // Store results for reporting
    const allRouteResults = [];

    for (const perm of permutations) {
        const currentRouteWaypoints = [startPoint, ...perm, endPoint];
        const routeDetails = await calculateRouteDetails(currentRouteWaypoints);

        if (routeDetails) {
            allRouteResults.push(routeDetails);

            if (routeDetails.duration < minDuration) {
                minDuration = routeDetails.duration;
                optimalRouteWaypoints = currentRouteWaypoints;
                // Reconstruct names based on optimal permutation
                const currentRouteNames = [startName];
                perm.forEach((p, index) => {
                    const originalIndex = stopLatLngs.findIndex(s => s.equals(p));
                    currentRouteNames.push(stopOriginalNames[originalIndex] || `Stop ${getStopLabel(index)}`);
                });
                currentRouteNames.push(endName);
                optimalRouteNames = currentRouteNames;
            }

            if (routeDetails.duration > maxDuration) {
                maxDuration = routeDetails.duration;
            }
            if (routeDetails.distance < minDistance) {
                minDistance = routeDetails.distance;
            }
            if (routeDetails.distance > maxDistance) {
                maxDistance = routeDetails.distance;
            }
        }
    }

    hideLoading();

    if (optimalRouteWaypoints.length > 0) {
        // Display the optimal route on the map
        createRouteWithMultipleStops(optimalRouteWaypoints, optimalRouteNames);
        showToast('Optimal route found and displayed!');

        // --- NEW CODE START ---
        // Prepare the optimal waypoint order as a JSON string for Android
        const optimalWaypointOrder = optimalRouteWaypoints.map((wp, index) => ({
            lat: wp.lat,
            lng: wp.lng,
            name: optimalRouteNames[index] || '', // Ensure name is always a string
            isStartPoint: index === 0,
            isEndPoint: index === optimalRouteWaypoints.length - 1
        }));
        const optimalWaypointOrderJson = JSON.stringify(optimalWaypointOrder);
        // --- NEW CODE END ---

        // Report results to Android
        if (typeof Android !== 'undefined' && Android.onSmartRouteCalculated) { // Added check for Android.onSmartRouteCalculated
            Android.onSmartRouteCalculated(
                (minDistance / 1000).toFixed(2),
                (minDuration / 60).toFixed(0),
                (maxDistance / 1000).toFixed(2),
                (maxDuration / 60).toFixed(0),
                optimalRouteWaypoints.length,
                optimalWaypointOrderJson // Pass the new JSON parameter here
            );
        }
        console.log('Smart Routing Complete:');
        console.log(`Min Time: ${Math.round(minDuration / 60)} min, Min Distance: ${(minDistance / 1000).toFixed(2)} km`);
        console.log(`Max Time: ${Math.round(maxDuration / 60)} min, Max Distance: ${(maxDistance / 1000).toFixed(2)} km`);
    } else {
        showToast('Could not find any routes for smart routing.');
        if (typeof Android !== 'undefined' && Android.onSmartRouteCalculated) { // Added check for Android.onSmartRouteCalculated
            Android.onSmartRouteCalculated('N/A', 'N/A', 'N/A', 'N/A', 0, "[]"); // Pass an empty JSON array if no route
        }
    }
}


    // Function to create route using Leaflet Routing Machine (original 2-point route)
    function createRoute(startLat, startLng, endLat, endLng, startName, endName) {
        clearRoutes();

        currentWaypoints = [
            L.latLng(startLat, startLng),
            L.latLng(endLat, endLng)
        ];
        currentWaypointNames = [startName, endName];

        currentRoute = L.Routing.control({
            waypoints: currentWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            createMarker: function(i, waypoint, n) {
                if (i === 0) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                        .bindPopup(startName || 'Start Point');
                } else if (i === n - 1) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                        .bindPopup(endName || 'End Point');
                }
                return L.marker(waypoint.latLng);
            },
            lineOptions: {
                styles: [
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#4285F4', weight: 6, opacity: 0.9}
                ]
            },
            show: true,
            showAlternatives: false,
            fitSelectedRoutes: true,
            collapsible: true,
            collapsed: false,
            autoRoute: true,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).on('routesfound', function(e) {
            let routes = e.routes;
            let summary = routes[0].summary;
            let distance = (summary.totalDistance / 1000).toFixed(2) + ' km';
            let duration = Math.round(summary.totalTime / 60) + ' min';

            setTimeout(() => {
                addCollapseButton();
            }, 100);

            if (typeof Android !== 'undefined') {
                Android.onRouteFound(distance, duration);
            }

            console.log('Route found:', distance, duration);
        }).on('routingerror', function(e) {
            console.error('Routing error:', e.error);
            if (typeof Android !== 'undefined') {
                Android.onRouteError(e.error.message || 'Failed to find route');
            }
        }).addTo(map);
    }

    // Function to create route with one stop (3-point route)
    function createRouteWithOneStop(startLat, startLng, stopLat, stopLng, endLat, endLng, startName, stopName, endName) {
        clearRoutes();

        currentWaypoints = [
            L.latLng(startLat, startLng),
            L.latLng(stopLat, stopLng),
            L.latLng(endLat, endLng)
        ];
        currentWaypointNames = [startName, stopName, endName];

        currentRoute = L.Routing.control({
            waypoints: currentWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            createMarker: function(i, waypoint, n) {
                if (i === 0) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                        .bindPopup(startName || 'Start Point');
                } else if (i === 1) {
                    // First stop gets label 'A'
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('stop', 'A') })
                        .bindPopup(stopName || 'Stop A');
                } else if (i === n - 1) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                        .bindPopup(endName || 'End Point');
                }
                return L.marker(waypoint.latLng);
            },
            lineOptions: {
                styles: [
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#4285F4', weight: 6, opacity: 0.9}
                ]
            },
            show: true,
            showAlternatives: false,
            fitSelectedRoutes: true,
            collapsible: true,
            collapsed: false,
            autoRoute: true,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).on('routesfound', function(e) {
            let routes = e.routes;
            let summary = routes[0].summary;
            let distance = (summary.totalDistance / 1000).toFixed(2) + ' km';
            let duration = Math.round(summary.totalTime / 60) + ' min';

            setTimeout(() => {
                addCollapseButton();
            }, 100);

            if (typeof Android !== 'undefined') {
                Android.onRouteFoundWithStop(distance, duration);
            }

            console.log('Route with stop found:', distance, duration);
        }).on('routingerror', function(e) {
            console.error('Routing error:', e.error);
            if (typeof Android !== 'undefined') {
                Android.onRouteError(e.error.message || 'Failed to find route');
            }
        }).addTo(map);
    }

    // Function to create route with multiple stops
    function createRouteWithMultipleStops(waypoints, waypointNames) {
        clearRoutes();

        // Ensure waypoints are L.LatLng objects
        let leafletWaypoints = waypoints.map(wp => {
            if (wp instanceof L.LatLng) {
                return wp;
            }
            return L.latLng(wp.lat || wp[0], wp.lng || wp[1]);
        });

        currentWaypoints = leafletWaypoints;
        currentWaypointNames = waypointNames;

        currentRoute = L.Routing.control({
            waypoints: leafletWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            createMarker: function(i, waypoint, n) {
                let name = waypointNames && waypointNames[i] ? waypointNames[i] : null;

                if (i === 0) {
                    // Start point
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                        .bindPopup(name || 'Start Point');
                } else if (i === n - 1) {
                    // End point
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                        .bindPopup(name || 'End Point');
                } else {
                    // Stop points - calculate alphabetical label
                    let stopIndex = getStopIndex(i, leafletWaypoints);
                    let stopLabel = getStopLabel(stopIndex);
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('stop', stopLabel) })
                        .bindPopup(name || `Stop ${stopLabel}`);
                }
            },
            lineOptions: {
                styles: [
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#4285F4', weight: 6, opacity: 0.9}
                ]
            },
            show: true,
            showAlternatives: false,
            fitSelectedRoutes: true,
            collapsible: true,
            collapsed: false,
            autoRoute: true,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).on('routesfound', function(e) {
            let routes = e.routes;
            let summary = routes[0].summary;
            let distance = (summary.totalDistance / 1000).toFixed(2) + ' km';
            let duration = Math.round(summary.totalTime / 60) + ' min';

            setTimeout(() => {
                addCollapseButton();
            }, 100);

            if (typeof Android !== 'undefined') {
                Android.onRouteFoundWithMultipleStops(distance, duration, waypoints.length);
            }

            console.log('Route with multiple stops found:', distance, duration);
        }).on('routingerror', function(e) {
            console.error('Routing error:', e.error);
            if (typeof Android !== 'undefined') {
                Android.onRouteError(e.error.message || 'Failed to find route');
            }
        }).addTo(map);
    }

    // Function to create route to custom destination
    function createRouteToDestination(startLat, startLng, destLat, destLng, destName) {
        createRoute(startLat, startLng, destLat, destLng, 'Your Location', destName);
    }

    // Function to create route with stop to custom destination
    function createRouteWithStopToDestination(startLat, startLng, stopLat, stopLng, destLat, destLng, stopName, destName) {
        createRouteWithOneStop(startLat, startLng, stopLat, stopLng, destLat, destLng, 'Your Location', stopName, destName);
    }

    // Function to create route with multiple stops to custom destination
    function createRouteWithMultipleStopsToDestination(startLat, startLng, stops, destLat, destLng, destName) {
        let waypoints = [
            { lat: startLat, lng: startLng }
        ];

        stops.forEach(stop => {
            waypoints.push({
                lat: stop.lat || stop[0],
                lng: stop.lng || stop[1],
                name: stop.name // Preserve name if available
            });
        });

        waypoints.push({ lat: destLat, lng: destLng });

        let names = ['Your Location'];
        stops.forEach((stop, index) => {
            names.push(stop.name || `Stop ${getStopLabel(index)}`);
        });
        names.push(destName);

        createRouteWithMultipleStops(waypoints, names);
    }

    // Legacy function to add route (keeping for backward compatibility)
    function addRoute(waypoints) {
        clearRoutes();

        if (waypoints.length >= 2) {
            let leafletWaypoints = waypoints.map(wp => L.latLng(wp[0], wp[1]));
            currentWaypoints = leafletWaypoints;
            currentWaypointNames = []; // Reset names for legacy function

            currentRoute = L.Routing.control({
                waypoints: leafletWaypoints,
                routeWhileDragging: false,
                addWaypoints: false,
                draggableWaypoints: false,
                createMarker: function(i, waypoint, n) {
                    if (i === 0) {
                        return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                            .bindPopup('Start Point');
                    } else if (i === n - 1) {
                        return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                            .bindPopup('End Point');
                    } else {
                        let stopIndex = getStopIndex(i, leafletWaypoints);
                        let stopLabel = getStopLabel(stopIndex);
                        return L.marker(waypoint.latLng, { icon: createCustomMarker('stop', stopLabel) })
                            .bindPopup(`Stop ${stopLabel}`);
                    }
                },
                lineOptions: {
                    styles: [
                        {color: '#FFFFFF', weight: 8, opacity: 0.8},
                        {color: '#4285F4', weight: 6, opacity: 0.9}
                    ]
                },
                show: true,
                showAlternatives: false,
                fitSelectedRoutes: true
            }).addTo(map);
        }
    }

    // Map click event
    map.on('click', function(e) {
        let lat = e.latlng.lat;
        let lng = e.latlng.lng;

        if (typeof Android !== 'undefined') {
            Android.onMapClick(lat, lng);
        }
    });

    // Function to add custom collapse button
    function addCollapseButton() {
        const container = document.querySelector('.leaflet-routing-container');
        if (container && !container.querySelector('.custom-collapse-btn')) {
            const collapseBtn = document.createElement('button');
            collapseBtn.className = 'custom-collapse-btn';
            collapseBtn.innerHTML = '−';
            collapseBtn.title = 'Collapse directions';
            collapseBtn.style.cssText = `
                background: #4285F4;
                color: white;
                border: none;
                border-radius: 50%;
                width: 28px;
                height: 28px;
                position: absolute;
                top: 8px;
                right: 8px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                z-index: 1000;
            `;

            let isCollapsed = false;
            collapseBtn.addEventListener('click', function() {
                const instructions = container.querySelector('.leaflet-routing-instructions');
                if (instructions) {
                    if (isCollapsed) {
                        instructions.style.display = 'block';
                        container.style.height = 'auto';
                        collapseBtn.innerHTML = '−';
                        collapseBtn.title = 'Collapse directions';
                    } else {
                        instructions.style.display = 'none';
                        container.style.height = '50px';
                        collapseBtn.innerHTML = '+';
                        collapseBtn.title = 'Expand directions';
                    }
                    isCollapsed = !isCollapsed;
                }
            });

            container.appendChild(collapseBtn);
        }
    }

    // Function to hide directions panel completely
    function hideDirections() {
        const container = document.querySelector('.leaflet-routing-container');
        if (container) {
            container.style.display = 'none';
        }
    }

    // Function to show directions panel
    function showDirections() {
        const container = document.querySelector('.leaflet-routing-container');
        if (container) {
            container.style.display = 'block';
        }
    }

    // Function to minimize directions (show only summary)
    function minimizeDirections() {
        const container = document.querySelector('.leaflet-routing-container');
        const instructions = container?.querySelector('.leaflet-routing-instructions');
        if (instructions) {
            instructions.style.display = 'none';
            container.style.height = '60px';
        }
    }

    // Show toast function (for Android communication or console log)
    function showToast(message) {
        if (typeof Android !== 'undefined') {
            Android.showToast(message);
        } else {
            console.log('Toast:', message);
        }
    }

    // Initialize map on load
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Map initialized');
        if (typeof Android !== 'undefined') {
            Android.showToast('Map loaded successfully');
        }
    });
</script>
</body>
</html>
