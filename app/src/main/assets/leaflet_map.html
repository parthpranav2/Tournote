<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaflet Route Planner Multiple Stops with Labels</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', Arial, sans-serif; /* Using Inter font */
            overflow: hidden; /* Prevent body scroll */
        }

        #map {
            width: 100%;
            height: 100vh;
            border-radius: 10px; /* Rounded corners for map */
        }

        .route-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 200px;
            font-size: 12px;
        }

        /* Custom marker styles */
        .custom-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-weight: bold;
            font-size: 12px;
            color: white;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .start-marker {
            background-color: #4CAF50; /* Green */
            width: 20px;
            height: 20px;
        }

        .stop-marker {
            background-color: #FF9800; /* Orange */
            width: 20px;
            height: 20px;
        }

        .end-marker {
            background-color: #F44336; /* Red */
            width: 20px;
            height: 20px;
        }

        /* Routing Container Styling */
        .leaflet-routing-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
            font-family: 'Inter', Tahoma, Geneva, Verdana, sans-serif; /* Using Inter font */
            max-width: 300px;
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            overflow: hidden; /* Ensure rounded corners clip content */
        }

        .leaflet-routing-container h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: #1976D2;
            font-weight: 600;
            padding: 12px 15px 0 15px;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 8px;
        }

        .leaflet-routing-container h3 {
            font-size: 14px;
            margin: 8px 0;
            color: #4285F4;
            font-weight: 500;
            background: #f8f9fa;
            padding: 8px 15px;
            margin: 0;
            border-radius: 6px;
            margin: 8px 12px;
        }

        .leaflet-routing-container .leaflet-routing-collapse-btn {
            background: #4285F4;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
        }

        .leaflet-routing-container .leaflet-routing-collapse-btn:hover {
            background: #1976D2;
        }

        .leaflet-routing-container .leaflet-routing-instruction {
            padding: 8px 15px;
            border-bottom: 1px solid #f5f5f5;
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }

        .leaflet-routing-container .leaflet-routing-instruction:hover {
            background: #f8f9fa;
        }

        .leaflet-routing-container .leaflet-routing-instruction:last-child {
            border-bottom: none;
        }

        .leaflet-routing-container .leaflet-routing-instruction-distance {
            color: #666;
            font-size: 11px;
            font-weight: 500;
        }

        .leaflet-routing-container .leaflet-routing-alt {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            margin: 8px 12px;
            padding: 8px;
        }

        .leaflet-routing-container .leaflet-routing-instructions {
            max-height: 200px;
            overflow-y: auto;
            border-radius: 0 0 10px 10px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar {
            width: 6px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar-thumb {
            background: #4285F4;
            border-radius: 3px;
        }

        .leaflet-routing-container .leaflet-routing-instructions::-webkit-scrollbar-thumb:hover {
            background: #1976D2;
        }

        .leaflet-routing-container.collapsed {
            height: 60px;
            overflow: hidden;
        }

        .leaflet-routing-container.collapsed .leaflet-routing-instructions {
            display: none;
        }

        /* Loading Overlay Styles (Updated for progress) */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark overlay */
            color: white;
            display: flex;
            flex-direction: column; /* Stacks spinner and text vertically */
            justify-content: center;
            align-items: center;
            z-index: 9999; /* Ensures it's on top of everything */
            font-family: 'Inter', Arial, sans-serif; /* Consistent font with your app */
            font-size: 1.4em; /* Increased base font size for overlay */
            visibility: hidden; /* Hidden by default */
            opacity: 0;
            transition: visibility 0s, opacity 0.3s linear; /* Smooth fade in/out */
        }

        #loadingOverlay .spinner {
            border: none; /* Remove old border */
            border-radius: 50%;
            width: 80px; /* Increased size */
            height: 80px; /* Increased size */
            /* Use conic-gradient for blue progress bar */
            background: conic-gradient(#4285F4 var(--progress, 0%), rgba(255, 255, 255, 0.3) 0%); /* Blue progress */
            /* Removed animation: spin */
            margin-bottom: 20px; /* Increased margin */
            display: flex; /* To position innerCircle */
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for absolute positioning of innerCircle */
        }

        /* New style for the inner circle */
        #loadingOverlay .spinner #innerCircle {
            position: absolute;
            width: calc(100% - 20px); /* Creates a 10px border-like gap for the progress bar (20px total) */
            height: calc(100% - 20px);
            border-radius: 50%;
            background-color: var(--inner-circle-color, hsl(0, 100%, 50%)); /* Initial red (hue 0) */
            display: flex;
            flex-direction: column; /* To stack percentage and estimated time */
            align-items: center;
            justify-content: center;
            transition: background-color 0.5s ease-in-out; /* Smooth color transition */
        }

        /* Style for the percentage text */
        #loadingOverlay .spinner #innerCircle #percentageText {
            font-size: 1em; /* Adjusted relative to new spinner size */
            font-weight: bold;
            color: white; /* Ensure text is visible on both red and green */
            text-shadow: 0 0 3px rgba(0,0,0,0.5); /* For better visibility */
        }

        /* Style for estimated time text inside the spinner */
        #loadingOverlay #estimatedTimeTextBelow { /* New ID for external element */
            font-size: 0.7em; /* Smaller font for estimated time */
            color: rgba(255, 255, 255, 0.8); /* Slightly less prominent */
            text-shadow: 0 0 3px rgba(0,0,0,0.5);
            margin-top: 5px; /* Small margin from progress text */
        }
    </style>
</head>
<body>

<div id="map"></div>

<!-- Loading Overlay HTML -->
<div id="loadingOverlay">
    <div class="spinner">
        <div id="innerCircle">
            <span id="percentageText">0%</span>
        </div>
    </div>
    <span id="loadingMessage">Calculating optimal route...</span>
    <span id="loadingProgressText"></span>
    <span id="estimatedTimeTextBelow"></span> <!-- Moved span for estimated time -->
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
<script>
    // Initialize the map with default location
    let map = L.map('map', { zoomControl: false }).setView([28.6139, 77.2090], 10);

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: ' OpenStreetMap contributors'
    }).addTo(map);

    // Store markers and routes
    let markers = [];
    let currentRoute = null;
    let currentWaypoints = []; // Store the last set of waypoints used for routing
    let currentWaypointNames = []; // Store the last set of waypoint names

    // Function to create custom marker with label
    function createCustomMarker(type, label = '') {
        let className = 'custom-marker';
        let content = label;
        switch(type) {
            case 'start':
                className += ' start-marker';
                content = ''; // Start point has no label
                break;
            case 'stop':
                className += ' stop-marker';
                break;
            case 'end':
                className += ' end-marker';
                content = ''; // End point has 'E' label
                break;
        }
        return L.divIcon({
            html: `<div class="${className}">${content}</div>`,
            iconSize: [20, 20],
            className: 'custom-div-icon'
        });
    }

    // Function to calculate stop index (similar to Android adapter)
    function getStopIndex(position, waypoints) {
        let stopCount = 0;
        for (let i = 0; i < position; i++) {
            if (i !== 0 && i !== waypoints.length - 1)
                stopCount++;
        }
        return stopCount;
    }

    // Function to get alphabetical label for stops
    function getStopLabel(stopIndex) {
        return String.fromCharCode(65 + stopIndex); // A, B, C, etc.
    }

    // Function to update location
    function updateLocation(lat, lng) {
        map.setView([lat, lng], 13);
    }

    // Function to add marker
    function addMarker(lat, lng, popup) {
        let marker = L.marker([lat, lng]).addTo(map);
        if (popup) {
            marker.bindPopup(popup);
            marker.on('click', function() {
                if (typeof Android !== 'undefined') {
                    Android.onMarkerClick(lat, lng, popup + ' Marker');
                }
            });
        }
        markers.push(marker);
        return marker;
    }

    // Function to clear all markers
    function clearMarkers() {
        markers.forEach(marker => map.removeLayer(marker));
        markers = [];
    }

    // Function to clear all routes
    function clearRoutes() {
        if (currentRoute) {
            map.removeControl(currentRoute);
            currentRoute = null;
        }
    }

    /**
     * Calculates route details (distance and duration) for a given set of waypoints without rendering on the map.
     * @param {Array<L.LatLng>} waypoints - An array of Leaflet LatLng objects.
     * @returns {Promise<{distance: number, duration: number} | null>} A promise resolving to an object with total distance (meters) and duration (seconds), or null if an error occurs
     */
    async function calculateRouteDetails(waypoints) {
        if (waypoints.length < 2) {
            console.warn("Not enough waypoints to calculate route details.");
            return null;
        }
        const coordinates = waypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
        const serviceUrl = `https://router.project-osrm.org/route/v1/driving/${coordinates}?overview=false&alternatives=false&steps=false`;

        try {
            const response = await fetch(serviceUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                return {
                    distance: route.distance, // meters
                    duration: route.duration // seconds
                };
            } else {
                console.warn("No routes found for the given waypoints.");
                return null;
            }
        } catch (error) {
            console.error("Error calculating route details:", error);
            return null;
        }
    }

    /**
     * Generates all permutations of an array.
     * @param {Array<any>} arr The input array.
     * @returns {Array<Array<any>>} An array containing all permutations.
     */
    function getPermutations(arr) {
        const result = [];
        function permute(current, remaining) {
            if (remaining.length === 0) {
                result.push(current);
                return;
            }
            for (let i = 0; i < remaining.length; i++) {
                const next = current.concat(remaining[i]);
                const newRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1));
                permute(next, newRemaining);
            }
        }
        permute([], arr);
        return result;
    }

    /**
     * Shows the loading indicator.
     */
    function showLoading() {
        const overlay = document.getElementById('loadingOverlay');
        const spinnerElement = document.querySelector('#loadingOverlay .spinner');
        const percentageTextElement = document.getElementById('percentageText');
        const innerCircleElement = document.getElementById('innerCircle');
        const estimatedTimeTextElement = document.getElementById('estimatedTimeTextBelow'); // Updated ID


        if (overlay && spinnerElement && percentageTextElement && innerCircleElement && estimatedTimeTextElement) {
            overlay.style.visibility = 'visible';
            overlay.style.opacity = '1';
            // Reset main message and clear progress text when showing
            document.getElementById('loadingMessage').innerText = 'Calculating optimal route...';
            document.getElementById('loadingProgressText').innerText = '';
            spinnerElement.style.setProperty('--progress', '0%'); // Reset progress
            percentageTextElement.innerText = '0%'; // Reset percentage text
            estimatedTimeTextElement.innerText = ''; // Clear estimated time text
            innerCircleElement.style.setProperty('--inner-circle-color', 'hsl(0, 100%, 50%)'); // Reset to red
        }
    }

    /**
     * Hides the loading indicator.
     */
    function hideLoading() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.style.opacity = '0';
            overlay.style.visibility = 'hidden';
        }
    }

    /**
     * Updates the progress text in the loading indicator.
     * @param {number} current - The current number of permutations processed.
     * @param {number} total - The total number of permutations.
     * @param {number} startTime - The timestamp when the smart routing started (milliseconds).
     */
    function updateLoadingProgress(current, total, startTime) {
        const progressTextElement = document.getElementById('loadingProgressText');
        const spinnerElement = document.querySelector('#loadingOverlay .spinner');
        const percentageTextElement = document.getElementById('percentageText');
        const innerCircleElement = document.getElementById('innerCircle');
        const estimatedTimeTextElement = document.getElementById('estimatedTimeTextBelow'); // Updated ID


        if (progressTextElement && spinnerElement && percentageTextElement && innerCircleElement && estimatedTimeTextElement) {
            const percentage = total === 0 ? 0 : (current / total) * 100;
            const clampedPercentage = Math.min(100, Math.max(0, percentage));

            const elapsedTime = (Date.now() - startTime) / 1000; // in seconds
            let estimatedTimeRemaining = 0;

            if (current > 0 && total > 0) {
                const progressRatio = current / total;
                const estimatedTotalTime = elapsedTime / progressRatio;
                estimatedTimeRemaining = estimatedTotalTime - elapsedTime;
            }

            const minutesRemaining = Math.floor(estimatedTimeRemaining / 60);
            const secondsRemaining = Math.round(estimatedTimeRemaining % 60);

            let estimatedTimeDisplay = '';
            if (estimatedTimeRemaining > 0) {
                if(minutesRemaining>0){
                estimatedTimeDisplay = `Estimated time. ${minutesRemaining}m ${secondsRemaining}s`;
                }else{
                estimatedTimeDisplay = `Estimated time. ${secondsRemaining}s`;
                }
            } else if (current === total && total > 0) {
                estimatedTimeDisplay = 'Completed!';
            }


            progressTextElement.innerText = `(${current} of ${total} options analyzed)`;
            estimatedTimeTextElement.innerText = estimatedTimeDisplay; // Update the new span
            percentageTextElement.innerText = `${Math.round(clampedPercentage)}%`;
            spinnerElement.style.setProperty('--progress', `${clampedPercentage}%`);

            const hue = (clampedPercentage / 100) * 120;
            innerCircleElement.style.setProperty('--inner-circle-color', `hsl(${hue}, 100%, 50%)`);

            // Send progress update to Android Kotlin file
            if (typeof Android !== 'undefined' && Android.onRouteCalculationProgress) {
                Android.onRouteCalculationProgress(current, total, Math.round(clampedPercentage), Math.round(estimatedTimeRemaining));
            }
        }
    }

    /**
     * Performs smart routing by trying all permutations of stop points to find the optimal route
     * with the minimum time, then updates the map with that route.
     * @param {number} startLat - Latitude of the start point.
     * @param {number} startLng - Longitude of the start point.
     * @param {Array<{lat: number, lng: number, name?: string}>} stopsArray - Array of stop point objects.
     * @param {number} endLat - Latitude of the end point.
     * @param {number} endLng - Longitude of the end point.
     * @param {string} startName - Name of the start point.
     * @param {Array<string>} stopNamesArray - Array of names for stop points.
     * @param {string} endName - Name of the end point.
     */
    async function performSmartRouting(startLat, startLng, stopsArray, endLat, endLng, startName, stopNamesArray, endName) {
        showLoading();
        const startTime = Date.now(); // Record start time

        if (stopsArray.length === 0) {
            // If no stops, just calculate the direct route
            createRoute(startLat, startLng, endLat, endLng, startName, endName);
            hideLoading();
            if (typeof Android !== 'undefined' && Android.onSmartRouteCalculated) {
                Android.onSmartRouteCalculated(
                    (0).toFixed(2), (0).toFixed(0), // Min distance/duration can be 0 or calculated direct values
                    (0).toFixed(2), (0).toFixed(0), // Max can be same as min for direct route
                    2, // Start and End points
                    JSON.stringify([{ lat: startLat, lng: startLng, name: startName, isStartPoint: true, isEndPoint: false }, { lat: endLat, lng: endLng, name: endName, isStartPoint: false, isEndPoint: true }])
                );
            }
            return;
        }

        const startPoint = L.latLng(startLat, startLng);
        const endPoint = L.latLng(endLat, endLng);

        // Convert stop objects to L.LatLng for permutation
        const stopLatLngs = stopsArray.map(s => L.latLng(s.lat, s.lng));
        const stopOriginalNames = stopsArray.map(s => s.name || '');

        const permutations = getPermutations(stopLatLngs);
        const totalPermutations = permutations.length;
        let completedCalculations = 0;

        let minDuration = Infinity;
        let optimalRouteWaypoints = [];
        let optimalRouteNames = [];
        let maxDuration = 0;
        let minDistance = Infinity;
        let maxDistance = 0;

        const allRouteResults = [];

        // Initial update for progress (0 out of total)
        updateLoadingProgress(completedCalculations, totalPermutations, startTime);

        for (const perm of permutations) {
            completedCalculations++;

            // Update progress in the UI after each calculation
            updateLoadingProgress(completedCalculations, totalPermutations, startTime);

            const currentRouteWaypoints = [startPoint, ...perm, endPoint];
            const routeDetails = await calculateRouteDetails(currentRouteWaypoints);

            if (routeDetails) {
                allRouteResults.push(routeDetails);

                if (routeDetails.duration < minDuration) {
                    minDuration = routeDetails.duration;
                    optimalRouteWaypoints = currentRouteWaypoints;
                    const currentRouteNames = [startName];
                    perm.forEach((p, index) => {
                        const originalIndex = stopLatLngs.findIndex(s => s.equals(p));
                        currentRouteNames.push(stopOriginalNames[originalIndex] || `Stop ${getStopLabel(index)}`);
                    });
                    currentRouteNames.push(endName);
                    optimalRouteNames = currentRouteNames;
                }

                if (routeDetails.duration > maxDuration) {
                    maxDuration = routeDetails.duration;
                }
                if (routeDetails.distance < minDistance) {
                    minDistance = routeDetails.distance;
                }
                if (routeDetails.distance > maxDistance) {
                    maxDistance = routeDetails.distance;
                }
            }
        }

        hideLoading();

        if (optimalRouteWaypoints.length > 0) {
            createRouteWithMultipleStops(optimalRouteWaypoints, optimalRouteNames);
            showToast('Optimal route found and displayed!');

            const optimalWaypointOrder = optimalRouteWaypoints.map((wp, index) => ({
                lat: wp.lat,
                lng: wp.lng,
                name: optimalRouteNames[index] || '',
                isStartPoint: index === 0,
                isEndPoint: index === optimalRouteWaypoints.length - 1
            }));
            const optimalWaypointOrderJson = JSON.stringify(optimalWaypointOrder);

            if (typeof Android !== 'undefined' && Android.onSmartRouteCalculated) {
                Android.onSmartRouteCalculated(
                    (minDistance / 1000).toFixed(2),
                    (minDuration / 60).toFixed(0),
                    (maxDistance / 1000).toFixed(2),
                    (maxDuration / 60).toFixed(0),
                    optimalRouteWaypoints.length,
                    optimalWaypointOrderJson
                );
            }
            console.log('Smart Routing Complete:');
            console.log(`Min Time: ${Math.round(minDuration / 60)} min, Min Distance: ${(minDistance / 1000).toFixed(2)} km`);
            console.log(`Max Time: ${Math.round(maxDuration / 60)} min, Max Distance: ${(maxDistance / 1000).toFixed(2)} km`);
        } else {
            showToast('Could not find any routes for smart routing.');
            if (typeof Android !== 'undefined' && Android.onSmartRouteCalculated) {
                Android.onSmartRouteCalculated('N/A', 'N/A', 'N/A', 'N/A', 0, "[]");
            }
        }
    }

    // Function to create route using Leaflet Routing Machine (original 2-point route)
    function createRoute(startLat, startLng, endLat, endLng, startName, endName) {
        clearRoutes();
        currentWaypoints = [
            L.latLng(startLat, startLng),
            L.latLng(endLat, endLng)
        ];
        currentWaypointNames = [startName, endName];
        currentRoute = L.Routing.control({
            waypoints: currentWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            createMarker: function(i, waypoint, n) {
                if (i === 0) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                        .bindPopup(startName || 'Start Point');
                } else if (i === n - 1) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                        .bindPopup(endName || 'End Point');
                }
                return L.marker(waypoint.latLng);
            },
            lineOptions: {
                styles: [
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#4285F4', weight: 6, opacity: 0.9}
                ]
            },
            show: true,
            showAlternatives: false,
            fitSelectedRoutes: true,
            collapsible: true,
            collapsed: false,
            autoRoute: true,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).on('routesfound', function(e) {
            let routes = e.routes;
            let summary = routes[0].summary;
            let distance = (summary.totalDistance / 1000).toFixed(2) + ' km';
            let duration = Math.round(summary.totalTime / 60) + ' min';
            setTimeout(() => {
                addCollapseButton();
            }, 100);
            if (typeof Android !== 'undefined') {
                Android.onRouteFound(distance, duration);
            }
            console.log('Route found:', distance, duration);
        }).on('routingerror', function(e) {
            console.error('Routing error:', e.error);
            if (typeof Android !== 'undefined') {
                Android.onRouteError(e.error.message || 'Failed to find route');
            }
        }).addTo(map);
    }
    // Function to create route with one stop (3-point route)
    function createRouteWithOneStop(startLat, startLng, stopLat, stopLng, endLat, endLng, startName, stopName, endName) {
        clearRoutes();
        currentWaypoints = [
            L.latLng(startLat, startLng),
            L.latLng(stopLat, stopLng),
            L.latLng(endLat, endLng)
        ];
        currentWaypointNames = [startName, stopName, endName];
        currentRoute = L.Routing.control({
            waypoints: currentWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            createMarker: function(i, waypoint, n) {
                if (i === 0) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                        .bindPopup(startName || 'Start Point');
                } else if (i === 1) {
                    // First stop gets label 'A'
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('stop', 'A') })
                        .bindPopup(stopName || 'Stop A');
                } else if (i === n - 1) {
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                        .bindPopup(endName || 'End Point');
                }
                return L.marker(waypoint.latLng);
            },
            lineOptions: {
                styles: [
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#4285F4', weight: 6, opacity: 0.9}
                ]
            },
            show: true,
            showAlternatives: false,
            fitSelectedRoutes: true,
            collapsible: true,
            collapsed: false,
            autoRoute: true,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).on('routesfound', function(e) {
            let routes = e.routes;
            let summary = routes[0].summary;
            let distance = (summary.totalDistance / 1000).toFixed(2) + ' km';
            let duration = Math.round(summary.totalTime / 60) + ' min';
            setTimeout(() => {
                addCollapseButton();
            }, 100);
            if (typeof Android !== 'undefined') {
                Android.onRouteFoundWithStop(distance, duration);
            }
            console.log('Route with stop found:', distance, duration);
        }).on('routingerror', function(e) {
            console.error('Routing error:', e.error);
            if (typeof Android !== 'undefined') {
                Android.onRouteError(e.error.message || 'Failed to find route');
            }
        }).addTo(map);
    }

    // Function to create route with multiple stops
    function createRouteWithMultipleStops(waypoints, waypointNames) {
        clearRoutes();
        // Ensure waypoints are L.LatLng objects
        let leafletWaypoints = waypoints.map(wp => {
            if (wp instanceof L.LatLng) {
                return wp;
            }
            return L.latLng(wp.lat || wp[0], wp.lng || wp[1]);
        });
        currentWaypoints = leafletWaypoints;
        currentWaypointNames = waypointNames;
        currentRoute = L.Routing.control({
            waypoints: leafletWaypoints,
            routeWhileDragging: false,
            addWaypoints: false,
            draggableWaypoints: false,
            createMarker: function(i, waypoint, n) {
                let name = waypointNames && waypointNames[i] ? waypointNames[i] : null;
                if (i === 0) {
                    // Start point
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                        .bindPopup(name || 'Start Point');
                } else if (i === n - 1) {
                    // End point
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                        .bindPopup(name || 'End Point');
                } else {
                    // Stop points - calculate alphabetical label
                    let stopIndex = getStopIndex(i, leafletWaypoints);
                    let stopLabel = getStopLabel(stopIndex);
                    return L.marker(waypoint.latLng, { icon: createCustomMarker('stop', stopLabel) })
                        .bindPopup(name || `Stop ${stopLabel}`);
                }
            },
            lineOptions: {
                styles: [
                    {color: '#FFFFFF', weight: 8, opacity: 0.8},
                    {color: '#4285F4', weight: 6, opacity: 0.9}
                ]
            },
            show: true,
            showAlternatives: false,
            fitSelectedRoutes: true,
            collapsible: true,
            collapsed: false,
            autoRoute: true,
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1',
                profile: 'driving'
            })
        }).on('routesfound', function(e) {
            let routes = e.routes;
            let summary = routes[0].summary;
            let distance = (summary.totalDistance / 1000).toFixed(2) + ' km';
            let duration = Math.round(summary.totalTime / 60) + ' min';
            setTimeout(() => {
                addCollapseButton();
            }, 100);
            if (typeof Android !== 'undefined') {
                Android.onRouteFoundWithMultipleStops(distance, duration, waypoints.length);
            }
            console.log('Route with multiple stops found:', distance, duration);
        }).on('routingerror', function(e) {
            console.error('Routing error:', e.error);
            if (typeof Android !== 'undefined') {
                Android.onRouteError(e.error.message || 'Failed to find route');
            }
        }).addTo(map);
    }

    // Function to create route to custom destination
    function createRouteToDestination(startLat, startLng, destLat, destLng, destName) {
        createRoute(startLat, startLng, destLat, destLng, 'Your Location', destName);
    }

    // Function to create route with stop to custom destination
    function createRouteWithStopToDestination(startLat, startLng, stopLat, stopLng, destLat, destLng, stopName, destName) {
        createRouteWithOneStop(startLat, startLng, stopLat, stopLng, destLat, destLng, 'Your Location', stopName, destName);
    }

    // Function to create route with multiple stops to custom destination
    function createRouteWithMultipleStopsToDestination(startLat, startLng, stops, destLat, destLng, destName) {
        let waypoints = [
            { lat: startLat, lng: startLng }
        ];
        stops.forEach(stop => {
            waypoints.push({
                lat: stop.lat || stop[0],
                lng: stop.lng || stop[1],
                name: stop.name // Preserve name if available
            });
        });
        waypoints.push({ lat: destLat, lng: destLng });
        let names = ['Your Location'];
        stops.forEach((stop, index) => {
            names.push(stop.name || `Stop ${getStopLabel(index)}`);
        });
        names.push(destName);
        createRouteWithMultipleStops(waypoints, names);
    }

    // Legacy function to add route (keeping for backward compatibility)
    function addRoute(waypoints) {
        clearRoutes();
        if (waypoints.length >= 2) {
            let leafletWaypoints = waypoints.map(wp => L.latLng(wp[0], wp[1]));
            currentWaypoints = leafletWaypoints;
            currentWaypointNames = []; // Reset names for legacy function
            currentRoute = L.Routing.control({
                waypoints: leafletWaypoints,
                routeWhileDragging: false,
                addWaypoints: false,
                draggableWaypoints: false,
                createMarker: function(i, waypoint, n) {
                    if (i === 0) {
                        return L.marker(waypoint.latLng, { icon: createCustomMarker('start') })
                            .bindPopup('Start Point');
                    } else if (i === n - 1) {
                        return L.marker(waypoint.latLng, { icon: createCustomMarker('end') })
                            .bindPopup('End Point');
                    } else {
                        let stopIndex = getStopIndex(i, leafletWaypoints);
                        let stopLabel = getStopLabel(stopIndex);
                        return L.marker(waypoint.latLng, { icon: createCustomMarker('stop', stopLabel) })
                            .bindPopup(`Stop ${stopLabel}`);
                    }
                },
                lineOptions: {
                    styles: [
                        {color: '#FFFFFF', weight: 8, opacity: 0.8},
                        {color: '#4285F4', weight: 6, opacity: 0.9}
                    ]
                },
                show: true,
                showAlternatives: false,
                fitSelectedRoutes: true
            }).addTo(map);
        }
    }

    // Map click event
    map.on('click', function(e) {
        let lat = e.latlng.lat;
        let lng = e.latlng.lng;
        if (typeof Android !== 'undefined') {
            Android.onMapClick(lat, lng);
        }
    });

    // Function to add custom collapse button
    function addCollapseButton() {
        const container = document.querySelector('.leaflet-routing-container');
        if (container && !container.querySelector('.custom-collapse-btn')) {
            const collapseBtn = document.createElement('button');
            collapseBtn.className = 'custom-collapse-btn';
            collapseBtn.innerHTML = '−';
            collapseBtn.title = 'Collapse directions';
            collapseBtn.style.cssText = `
                background: #4285F4;
                color: white;
                border: none;
                border-radius: 50%;
                width: 28px;
                height: 28px;
                position: absolute;
                top: 8px;
                right: 8px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 16px;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                z-index: 1000;
            `;
            let isCollapsed = false;
            collapseBtn.addEventListener('click', function() {
                const instructions = container.querySelector('.leaflet-routing-instructions');
                if (instructions) {
                    if (isCollapsed) {
                        instructions.style.display = 'block';
                        container.style.height = 'auto';
                        collapseBtn.innerHTML = '−';
                        collapseBtn.title = 'Collapse directions';
                    } else {
                        instructions.style.display = 'none';
                        container.style.height = '50px';
                        collapseBtn.innerHTML = '+';
                        collapseBtn.title = 'Expand directions';
                    }
                    isCollapsed = !isCollapsed;
                }
            });
            container.appendChild(collapseBtn);
        }
    }

    // Function to hide directions panel completely
    function hideDirections() {
        const container = document.querySelector('.leaflet-routing-container');
        if (container) {
            container.style.display = 'none';
        }
    }

    // Function to show directions panel
    function showDirections() {
        const container = document.querySelector('.leaflet-routing-container');
        if (container) {
            container.style.display = 'block';
        }
    }

    // Function to minimize directions (show only summary)
    function minimizeDirections() {
        const container = document.querySelector('.leaflet-routing-container');
        const instructions = container?.querySelector('.leaflet-routing-instructions');
        if (instructions) {
            instructions.style.display = 'none';
            container.style.height = '60px';
        }
    }

    // Show toast function (for Android communication or console log)
    function showToast(message) {
        if (typeof Android !== 'undefined') {
            Android.showToast(message);
        } else {
            console.log('Toast:', message);
        }
    }

    // Initialize map on load
    document.addEventListener('DOMContentLoaded', function() {
        console.log('Map initialized');
        if (typeof Android !== 'undefined') {
            Android.showToast('Map loaded successfully');
        }
    });
</script>
</body>
</html>
